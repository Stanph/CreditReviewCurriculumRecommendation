"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var node_1 = require("@malagu/web/lib/node");
function parseApiGatewayContext(event, context, callback) {
    var e = JSON.parse(event);
    var request = {
        method: e.method,
        path: e.path,
        url: e.path,
        connection: {},
        query: e.queryParameters || {},
        headers: e.headers,
        get body() {
            var body = e.isBase64Encoded ? Buffer.from(e.body, 'base64').toString('utf8') : e.body;
            if (e.headers['content-type'] === 'application/json') {
                return JSON.parse(body);
            }
        }
    };
    var res = {
        headers: {},
        isBase64Encoded: false
    };
    var response = {
        setHeader: function (name, value) {
            res.headers[name] = value;
        },
        getHeader: function (name) {
            return this.getHeaders()[name];
        },
        getHeaders: function () {
            return res.headers;
        },
        get statusCode() {
            return res.statusCode;
        },
        finished: false,
        set statusCode(statusCode) {
            res.statusCode = statusCode;
        },
        end: function (chunk, encoding, cb) {
            callback(undefined, __assign(__assign({}, res), { body: chunk }));
        }
    };
    var ctx = new node_1.HttpContext(request, response);
    ctx.event = event;
    ctx.context = context;
    ctx.callback = callback;
    return ctx;
}
exports.parseApiGatewayContext = parseApiGatewayContext;
function ParseHttpTriggerContext(req, res, context) {
    var request = req;
    if (req.queries) {
        request.query = req.queries;
        request.connection = {};
    }
    if (req.headers['content-type'] === 'application/json') {
        request.body = request.body ? JSON.parse(request.body) : request.body;
    }
    var response = {
        setHeader: function (name, value) {
            res.setHeader(name, value);
        },
        getHeader: function (name) {
            return res.getHeader ? res.getHeader(name) : (this.getHeaders()[name] ? this.getHeaders()[name] : res.headersMap[name]);
        },
        getHeaders: function () {
            return res.headers || res.getHeaders();
        },
        get statusCode() {
            return res.statusCode;
        },
        set statusCode(statusCode) {
            res.statusCode = statusCode;
        },
        finished: false,
        end: function (chunk, encoding, cb) {
            this.finished = true;
            // eslint-disable-next-line no-null/no-null
            res.send(chunk === undefined || chunk === null ? '' : chunk);
        }
    };
    var ctx = new node_1.HttpContext(request, response);
    ctx.context = context;
    return ctx;
}
exports.ParseHttpTriggerContext = ParseHttpTriggerContext;
//# sourceMappingURL=context.js.map