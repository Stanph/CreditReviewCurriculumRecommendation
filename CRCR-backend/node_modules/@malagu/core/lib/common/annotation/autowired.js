"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var inversify_1 = require("inversify");
var container_1 = require("../container");
var AutowiredOption;
(function (AutowiredOption) {
    function is(options) {
        return options && (options.id !== undefined || options.detached !== undefined);
    }
    AutowiredOption.is = is;
})(AutowiredOption = exports.AutowiredOption || (exports.AutowiredOption = {}));
exports.Autowired = function (target, targetKey, index) {
    var option = getAutowiredOption(target, targetKey, index);
    if (targetKey === undefined && index === undefined) {
        return function (t, tk, i) {
            applyAutowiredDecorator(option, t, tk, i);
        };
    }
    else {
        applyAutowiredDecorator(option, target, targetKey, index);
    }
};
function getAutowiredOption(target, targetKey, index) {
    var option = {};
    if (targetKey === undefined) {
        if (AutowiredOption.is(target)) {
            option = __assign({}, target);
        }
        else if (target) {
            option = { id: target };
        }
    }
    return option;
}
exports.getAutowiredOption = getAutowiredOption;
function applyAutowiredDecorator(option, target, targetKey, index, doInject, doGetValue) {
    if (doInject === void 0) { doInject = function (id, isMulti, t, k, i) {
        if (isMulti) {
            inversify_1.multiInject(id)(t, k, i);
        }
        else {
            inversify_1.inject(id)(target, targetKey, index);
        }
    }; }
    if (doGetValue === void 0) { doGetValue = function (id, isMulti, container, t, property) {
        if (isMulti) {
            return container.getAll(id);
        }
        else {
            return container.get(id);
        }
    }; }
    var type;
    if (index !== undefined) {
        type = Reflect.getMetadata('design:paramtypes', target, targetKey)[index];
    }
    else {
        type = Reflect.getMetadata('design:type', target, targetKey);
    }
    var isMlt = type === Array;
    var defaultAutowiredOption = {
        id: type,
        detached: false
    };
    var opt = __assign(__assign({}, defaultAutowiredOption), option);
    if (opt.detached) {
        if (index !== undefined) {
            throw new Error("The " + target.constructor.name + " itself is not injected into the container, so the parameter injection of the constructor is not supported.");
        }
        createAutowiredProperty(opt, isMlt, doGetValue, target, targetKey);
        return;
    }
    else {
        doInject(opt.id, isMlt, target, targetKey, index);
    }
}
exports.applyAutowiredDecorator = applyAutowiredDecorator;
function createAutowiredProperty(option, isMulti, doGetValue, target, property) {
    var value;
    Object.defineProperty(target, property, {
        enumerable: true,
        get: function () {
            if (value !== undefined) {
                return value;
            }
            var container = container_1.ContainerProvider.provide();
            var id = option.id;
            value = doGetValue(id, isMulti, container, target, property);
            return value;
        }
    });
}
exports.createAutowiredProperty = createAutowiredProperty;
//# sourceMappingURL=autowired.js.map