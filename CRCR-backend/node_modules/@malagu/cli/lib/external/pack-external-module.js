"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var path_1 = require("path");
var context_1 = require("../context");
var packager_1 = require("../packager");
var constants_1 = require("../constants");
var fs_extra_1 = require("fs-extra");
var isBuiltinModule = require('is-builtin-module');
function rebaseFileReferences(pathToPackageRoot, moduleVersion) {
    if (/^(?:file:[^/]{2}|\.\/|\.\.\/)/.test(moduleVersion)) {
        var filePath = moduleVersion.replace(/^file:/, '');
        return ("" + (moduleVersion.startsWith('file:') ? 'file:' : '') + pathToPackageRoot + "/" + filePath).replace(/\\/g, '/');
    }
    return moduleVersion;
}
/**
 * Add the given modules to a package json's dependencies.
 */
function addModulesToPackageJson(externalModules, packageJson, pathToPackageRoot) {
    externalModules.forEach(function (externalModule) {
        var splitModule = externalModule.split('@');
        // If we have a scoped module we have to re-add the @
        if (externalModule.startsWith('@')) {
            splitModule.splice(0, 1);
            splitModule[0] = '@' + splitModule[0];
        }
        var moduleVersion = splitModule.slice(1).join('@');
        // We have to rebase file references to the target package.json
        moduleVersion = rebaseFileReferences(pathToPackageRoot, moduleVersion);
        packageJson.dependencies = packageJson.dependencies || {};
        packageJson.dependencies[splitModule[0]] = moduleVersion;
    });
}
/**
 * Remove a given list of excluded modules from a module list
 * @this - The active plugin instance
 */
function removeExcludedModules(modules, packageForceExcludes, log) {
    var excludedModules = lodash_1.remove(modules, function (externalModule) {
        var splitModule = externalModule.split('@');
        // If we have a scoped module we have to re-add the @
        if (externalModule.startsWith('@')) {
            splitModule.splice(0, 1);
            splitModule[0] = '@' + splitModule[0];
        }
        var moduleName = splitModule[0];
        return packageForceExcludes.indexOf((moduleName)) !== -1;
    });
    if (log && excludedModules.length > 0) {
        console.log("Excluding external modules: " + excludedModules.join(', '));
    }
}
/**
 * Resolve the needed versions of production dependencies for external modules.
 * @this - The active plugin instance
 */
function getProdModules(externalModules, packagePath, dependencyGraph, forceExcludes) {
    var e_1, _a;
    var packageJson = fs_extra_1.readJSONSync(packagePath);
    var prodModules = [];
    // only process the module stated in dependencies section
    if (!packageJson.dependencies) {
        return [];
    }
    try {
        // Get versions of all transient modules
        for (var externalModules_1 = __values(externalModules), externalModules_1_1 = externalModules_1.next(); !externalModules_1_1.done; externalModules_1_1 = externalModules_1.next()) {
            var module_1 = externalModules_1_1.value;
            var moduleVersion = packageJson.dependencies[module_1.external];
            if (moduleVersion) {
                prodModules.push(module_1.external + "@" + moduleVersion);
                // Check if the module has any peer dependencies and include them too
                try {
                    var modulePackagePath = path_1.join(path_1.dirname(path_1.join(process.cwd(), packagePath)), 'node_modules', module_1.external, 'package.json');
                    var peerDependencies = fs_extra_1.readJSONSync(modulePackagePath).peerDependencies;
                    if (!lodash_1.isEmpty(peerDependencies)) {
                        console.log("Adding explicit peers for dependency " + module_1.external);
                        var peerModules = getProdModules(Object.keys(peerDependencies).map(function (value) { return ({ external: value }); }), packagePath, dependencyGraph, forceExcludes);
                        prodModules.push.apply(prodModules, __spread(peerModules));
                    }
                }
                catch (e) {
                    console.log("WARNING: Could not check for peer dependencies of " + module_1.external);
                }
            }
            else {
                if (!packageJson.devDependencies || !packageJson.devDependencies[module_1.external]) {
                    // Add transient dependencies if they appear not in the service's dev dependencies
                    var originInfo = lodash_1.get(dependencyGraph, 'dependencies', {})[module_1.origin] || {};
                    moduleVersion = lodash_1.get(lodash_1.get(originInfo, 'dependencies', {})[module_1.external], 'version');
                    if (!moduleVersion) {
                        console.log("WARNING: Could not determine version of module " + module_1.external);
                    }
                    prodModules.push(moduleVersion ? module_1.external + "@" + moduleVersion : module_1.external);
                }
                else if (packageJson.devDependencies &&
                    packageJson.devDependencies[module_1.external] &&
                    !(forceExcludes.indexOf(module_1.external) !== -1)) {
                    // To minimize the chance of breaking setups we whitelist packages available on AWS here. These are due to the previously missing check
                    // most likely set in devDependencies and should not lead to an error now.
                    var ignoredDevDependencies = ['aws-sdk'];
                    if (ignoredDevDependencies.indexOf(module_1.external) !== -1) {
                        // Runtime dependency found in devDependencies but not forcefully excluded
                        console.error("ERROR: Runtime dependency '" + module_1.external + "' found in devDependencies. Move it to dependencies or use forceExclude to explicitly exclude it.");
                        throw new Error("Serverless-webpack dependency error: " + module_1.external + ".");
                    }
                    console.log("INFO: Runtime dependency '" + module_1.external + "' found in devDependencies. It has been excluded automatically.");
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (externalModules_1_1 && !externalModules_1_1.done && (_a = externalModules_1.return)) _a.call(externalModules_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return prodModules;
}
function getExternalModuleName(module) {
    var path = /^external "(.*)"$/.exec(module.identifier())[1];
    var pathComponents = path.split('/');
    var main = pathComponents[0];
    // this is a package within a namespace
    if (main.charAt(0) === '@') {
        return main + "/" + pathComponents[1];
    }
    return main;
}
function isExternalModule(module) {
    return module.identifier().startsWith('external ') && !isBuiltinModule(getExternalModuleName(module));
}
/**
 * Find the original module that required the transient dependency. Returns
 * undefined if the module is a first level dependency.
 * @param {Object} issuer - Module issuer
 */
function findExternalOrigin(issuer) {
    if (!lodash_1.isNil(issuer) && issuer.rawRequest.startsWith('./')) {
        return findExternalOrigin(issuer.issuer);
    }
    return issuer;
}
function getExternalModules(stats) {
    var e_2, _a, e_3, _b;
    if (!stats.compilation.chunks) {
        return [];
    }
    var externals = new Set();
    try {
        for (var _c = __values(stats.compilation.chunks), _d = _c.next(); !_d.done; _d = _c.next()) {
            var chunk = _d.value;
            if (!chunk.modulesIterable) {
                continue;
            }
            try {
                // Explore each module within the chunk (built inputs):
                for (var _e = (e_3 = void 0, __values(chunk.modulesIterable)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var module_2 = _f.value;
                    if (isExternalModule(module_2)) {
                        externals.add({
                            origin: lodash_1.get(findExternalOrigin(module_2.issuer), 'rawRequest'),
                            external: getExternalModuleName(module_2)
                        });
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return Array.from(externals);
}
/**
 * We need a performant algorithm to install the packages for each single
 * function (in case we package individually).
 * (1) We fetch ALL packages needed by ALL functions in a first step
 * and use this as a base npm checkout. The checkout will be done to a
 * separate temporary directory with a package.json that contains everything.
 * (2) For each single compile we copy the whole node_modules to the compile
 * directory and create a (function) compile specific package.json and store
 * it in the compile directory. Now we start npm again there, and npm will just
 * remove the superfluous packages and optimize the remaining dependencies.
 * This will utilize the npm cache at its best and give us the needed results
 * and performance.
 */
function packExternalModules(context, stats) {
    return __awaiter(this, void 0, void 0, function () {
        var verbose, pkg, config, configuration, packagerId, includes, packagerOptions, scripts, outputPath, packageForceIncludes, packageForceExcludes, packagePath, packageScripts, packager, sectionNames, packageJson, packageSections, dependencyGraph, problems, externalModules, compositeModules, compositeModulePath, compositePackageJson, compositePackage, relPath, packageLockPath, hasPackageLock, packageLockFile, err_1, start, startPrune, startRunScripts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    verbose = false;
                    pkg = context.pkg;
                    config = pkg.backendConfig.malagu;
                    configuration = context_1.HookContext.getConfiguration(constants_1.BACKEND_TARGET, context.configurations);
                    packagerId = config.packager;
                    includes = config.includeModules;
                    packagerOptions = config.packagerOptions || {};
                    scripts = packagerOptions.scripts || [];
                    if (!includes || !configuration) {
                        return [2 /*return*/];
                    }
                    outputPath = configuration.output.path;
                    packageForceIncludes = includes.forceInclude || [];
                    packageForceExcludes = includes.forceExclude || [];
                    packagePath = includes.packagePath && path_1.join(pkg.projectPath, includes.packagePath) || pkg.packagePath;
                    packageScripts = scripts.reduce(function (accumulator, script, index) {
                        accumulator["script" + index] = script;
                        return accumulator;
                    }, {});
                    packager = packager_1.getPackager(packagerId);
                    sectionNames = packager.copyPackageSectionNames;
                    return [4 /*yield*/, fs_extra_1.readJSON(packagePath)];
                case 1:
                    packageJson = _a.sent();
                    packageSections = lodash_1.pick(packageJson, sectionNames);
                    if (!lodash_1.isEmpty(packageSections)) {
                        console.log("Using package.json sections " + Object.keys(packageSections).join(', '));
                    }
                    return [4 /*yield*/, packager.getProdDependencies(pkg.projectPath, 1)];
                case 2:
                    dependencyGraph = _a.sent();
                    problems = dependencyGraph.problems || [];
                    if (verbose && !lodash_1.isEmpty(problems)) {
                        console.log("Ignoring " + problems.length + " NPM errors:");
                        problems.forEach(function (problem) {
                            console.log("=> " + problem);
                        });
                    }
                    externalModules = getExternalModules(stats).concat(packageForceIncludes.map(function (whitelistedPackage) { return ({
                        external: whitelistedPackage
                    }); }));
                    compositeModules = lodash_1.uniq(getProdModules(externalModules, packagePath, dependencyGraph, packageForceExcludes));
                    removeExcludedModules(compositeModules, packageForceExcludes, true);
                    if (lodash_1.isEmpty(compositeModules)) {
                        // The compiled code does not reference any external modules at all
                        console.log('No external modules needed');
                        return [2 /*return*/];
                    }
                    compositeModulePath = outputPath;
                    compositePackageJson = path_1.join(compositeModulePath, 'package.json');
                    compositePackage = lodash_1.defaults({
                        name: pkg.pkg.name,
                        version: pkg.pkg.version,
                        description: "Packaged externals for " + pkg.pkg.name,
                        private: true,
                        scripts: packageScripts
                    }, packageSections);
                    relPath = path_1.relative(compositeModulePath, path_1.dirname(packagePath));
                    addModulesToPackageJson(compositeModules, compositePackage, relPath);
                    fs_extra_1.writeJSONSync(compositePackageJson, compositePackage, { spaces: 2 });
                    packageLockPath = path_1.join(path_1.dirname(packagePath), packager.lockfileName);
                    return [4 /*yield*/, fs_extra_1.pathExists(packageLockPath)];
                case 3:
                    hasPackageLock = _a.sent();
                    if (!hasPackageLock) return [3 /*break*/, 8];
                    console.log('Package lock found - Using locked versions');
                    _a.label = 4;
                case 4:
                    _a.trys.push([4, 7, , 8]);
                    return [4 /*yield*/, packager.readLockfile(packageLockPath)];
                case 5:
                    packageLockFile = _a.sent();
                    packageLockFile = packager.rebaseLockfile(relPath, packageLockFile);
                    return [4 /*yield*/, packager.writeLockfile(path_1.join(compositeModulePath, packager.lockfileName), packageLockFile)];
                case 6:
                    _a.sent();
                    return [3 /*break*/, 8];
                case 7:
                    err_1 = _a.sent();
                    console.warn("Warning: Could not read lock file: " + err_1.message);
                    return [3 /*break*/, 8];
                case 8:
                    start = lodash_1.now();
                    console.log('Packing external modules: ' + compositeModules.join(', '));
                    return [4 /*yield*/, packager.install(compositeModulePath, packagerOptions)];
                case 9:
                    _a.sent();
                    if (verbose) {
                        console.log("Package took [" + (lodash_1.now() - start) + " ms]");
                    }
                    startPrune = lodash_1.now();
                    return [4 /*yield*/, packager.prune(compositeModulePath, packagerOptions)];
                case 10:
                    _a.sent();
                    if (verbose) {
                        console.log("Prune: " + compositeModulePath + " [" + (lodash_1.now() - startPrune) + " ms]");
                    }
                    startRunScripts = lodash_1.now();
                    return [4 /*yield*/, packager.runScripts(compositeModulePath, Object.keys(packageScripts))];
                case 11:
                    _a.sent();
                    if (verbose) {
                        console.log("Run scripts: " + compositeModulePath + " [" + (lodash_1.now() - startRunScripts) + " ms]");
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.packExternalModules = packExternalModules;
//# sourceMappingURL=pack-external-module.js.map